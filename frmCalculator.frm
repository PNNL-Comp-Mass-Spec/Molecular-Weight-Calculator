VERSION 5.00
Object = "{3B7C8863-D78F-101B-B9B5-04021C009402}#1.2#0"; "richtx32.ocx"
Begin VB.Form frmCalculator 
   Caption         =   "Calculator"
   ClientHeight    =   1110
   ClientLeft      =   165
   ClientTop       =   840
   ClientWidth     =   7035
   Icon            =   "frmCalculator.frx":0000
   LinkTopic       =   "Form1"
   MaxButton       =   0   'False
   ScaleHeight     =   1110
   ScaleWidth      =   7035
   StartUpPosition =   3  'Windows Default
   Tag             =   "6500"
   Begin VB.TextBox txtStatus 
      Appearance      =   0  'Flat
      BackColor       =   &H8000000F&
      BorderStyle     =   0  'None
      BeginProperty Font 
         Name            =   "MS Sans Serif"
         Size            =   9.75
         Charset         =   0
         Weight          =   400
         Underline       =   0   'False
         Italic          =   0   'False
         Strikethrough   =   0   'False
      EndProperty
      Height          =   240
      Left            =   120
      Locked          =   -1  'True
      TabIndex        =   3
      TabStop         =   0   'False
      Text            =   "Status"
      Top             =   720
      Width           =   4815
   End
   Begin VB.CommandButton cmdOK 
      Cancel          =   -1  'True
      Caption         =   "Cl&ose"
      Height          =   360
      Left            =   5280
      TabIndex        =   2
      Tag             =   "4000"
      Top             =   600
      Width           =   1155
   End
   Begin VB.CommandButton cmdCalculate 
      Caption         =   "&Calculate"
      Default         =   -1  'True
      Height          =   375
      Left            =   5160
      TabIndex        =   1
      Tag             =   "6520"
      ToolTipText     =   "Evaluates the current expression"
      Top             =   120
      Width           =   1455
   End
   Begin RichTextLib.RichTextBox rtfExpression 
      Height          =   495
      Left            =   120
      TabIndex        =   0
      Tag             =   "6510"
      ToolTipText     =   "Enter a mathematical expression to evaluate here"
      Top             =   120
      Width           =   4815
      _ExtentX        =   8493
      _ExtentY        =   873
      _Version        =   393217
      Enabled         =   -1  'True
      MultiLine       =   0   'False
      TextRTF         =   $"frmCalculator.frx":08CA
   End
   Begin VB.Menu mnuRightClick 
      Caption         =   "RightClickMenu"
      Begin VB.Menu mnuRightClickUndo 
         Caption         =   "&Undo"
      End
      Begin VB.Menu mnuRightClickSep1 
         Caption         =   "-"
      End
      Begin VB.Menu mnuRightClickCut 
         Caption         =   "Cu&t"
      End
      Begin VB.Menu mnuRightClickCopy 
         Caption         =   "&Copy"
      End
      Begin VB.Menu mnuRightClickPaste 
         Caption         =   "&Paste"
      End
      Begin VB.Menu mnuRightClickDelete 
         Caption         =   "&Delete"
      End
      Begin VB.Menu mnuRightClickSep2 
         Caption         =   "-"
      End
      Begin VB.Menu mnuRightClickSelectAll 
         Caption         =   "Select &All"
      End
   End
End
Attribute VB_Name = "frmCalculator"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Option Explicit

' Form wide globals
Private strComputationResult As String
Private boolExpressionChanged As Boolean

Private mCalculatorErrorID As Long
Private mCalculatorErrorPosition As Long
Private mDecimalSeparator As String

' Purpose: Hande errors generated by ParseNum
Private Sub CatchParsenumErrorInCalculator(AdjacentNum As Double, Optional boolInspectingCaret As Boolean = False)

    If AdjacentNum < 0 Then
        Select Case AdjacentNum
        Case -1
            ' Error: No number
            If boolInspectingCaret Then
                mCalculatorErrorID = 15         ' LookupMessage(89)
            Else
                ' Ignore the missing number
            End If
        Case -3
            ' Error: No number after decimal point
            ' Return message 'Misplaced number'
            mCalculatorErrorID = 21             ' LookupMessage(95)
        Case -4
            ' Error: More than one decimal point
            mCalculatorErrorID = 16             ' LookupMessage(90)
        Case Else
            ' Error: General number error
            ' Return message 'Misplaced number'
            mCalculatorErrorID = 4             ' LookupMessage(78)
        End Select
    End If
    
End Sub

Private Sub CopyRoutinePrivate()
    ' Copy text from rtfExpression to the clipboard
    
    Dim strCopyText As String
    
    strCopyText = rtfExpression.SelText
        
    RemoveHeightAdjustChar strCopyText
    
    ' Copy corrected text to Clipboard.
    Clipboard.Clear
    Clipboard.SetText strCopyText, vbCFText

End Sub

' Purpose: Take a number to a power
Private Function DoPower(dblWorkNum As Double, strExpression As String, intIndexOfStartOfFirstNumber As Integer, ByVal intOffsetToSecondNumber As Integer, ByRef intNumSizing As Integer) As Double
    ' Note: intNumSizing holds the length of the first number when this expression is called
    '       Later in the expression the length of the second number (and 1 for the caret) is
    '         added to intNumSizing such that it then holds the length of both numbers and the caret
    
    Dim intNumSizingFirstNumber As Integer, dblPowerNum As Double
    Dim intNumSizingSecondNumber As Integer
    
    ' Need to take sum in parentheses to power before continuing
    intNumSizingFirstNumber = intNumSizing
    
    If Mid(strExpression, intIndexOfStartOfFirstNumber + intNumSizingFirstNumber + intOffsetToSecondNumber, 1) = "-" Then
        ' Ability to handle negative powers
        dblPowerNum = ParseNum(Mid(strExpression, intIndexOfStartOfFirstNumber + intNumSizingFirstNumber + intOffsetToSecondNumber + 1), intNumSizingSecondNumber)
        CatchParsenumErrorInCalculator dblPowerNum, True
        If dblPowerNum >= 0 Then
            dblPowerNum = -dblPowerNum
            intNumSizing = intNumSizing + 1
        End If
    Else
        dblPowerNum = ParseNum(Mid(strExpression, intIndexOfStartOfFirstNumber + intNumSizingFirstNumber + intOffsetToSecondNumber), intNumSizingSecondNumber)
        CatchParsenumErrorInCalculator dblPowerNum, True
    End If
    
    If mCalculatorErrorID = 0 Then
        If dblWorkNum < 0 And dblPowerNum <> CIntSafeDbl(dblPowerNum) Then
            ' Cannot take a negative number to a decimal power
            mCalculatorErrorID = 11
        ElseIf dblWorkNum = 0 Then
            If dblPowerNum < 0 Then
                ' Cannot take zero to a negative power
                mCalculatorErrorID = 12
            ElseIf dblPowerNum = 0 Then
                ' Cannot take zero to the zeroth power
                mCalculatorErrorID = 13
            End If
        End If
        If mCalculatorErrorID = 0 Then
            ' intNumSizingFirstNumber contains the length of the first number (m in m^n)
            ' intNumSizing contains the length of the second number (n in m^n)
            intNumSizing = intNumSizingFirstNumber + intNumSizingSecondNumber + 1
            DoPower = dblWorkNum ^ dblPowerNum
        End If
    End If
    
    If mCalculatorErrorID <> 0 Then
        mCalculatorErrorPosition = intIndexOfStartOfFirstNumber + intOffsetToSecondNumber + intNumSizingFirstNumber
        intIndexOfStartOfFirstNumber = Len(strExpression)
    End If

End Function

' Purpose: Compute a result based on rtfExpression.Text; display in strComputationResult
Private Sub InitiateMathCalculate()
    Dim dblResult As Double
    
    mCalculatorErrorID = 0
    If boolExpressionChanged Then
        dblResult = PerformMath(rtfExpression.Text, 1)
        
        If frmProgramPreferences.optStdDevType(1).value = True Or Abs(dblResult) >= 10000000# Then
            ' Use scientific notation
            strComputationResult = Format(dblResult, "0.###############E+00")
        Else
            ' Display result in 0.000 notation rather than exponential
            If Abs(dblResult) >= 10000# Then
                ' Display with commas
                strComputationResult = Format(dblResult, "#,##0.################")
            Else
                ' Leave out the commas
                strComputationResult = Format(dblResult, "#0.###############")
            End If
            If Right(strComputationResult, 1) = "." Then
                strComputationResult = Left(strComputationResult, Len(strComputationResult) - 1)
            End If
        End If
    End If
    
    If mCalculatorErrorID > 0 Then                     ' Inform user of error and location
        txtStatus.ForeColor = QBColor(COLOR_ERR)
        ' Calculator error codes are 75 to 99
        txtStatus.Text = LookupMessage(mCalculatorErrorID + 74)
        
        Form_Resize
    Else
        ' Display sum
        txtStatus.ForeColor = vbWindowText
        txtStatus.Text = LookupLanguageCaption(6610, "Result ") & " = " & strComputationResult
    End If

End Sub

' Purpose: Update txtstatus
Private Sub LabelStatus()
    If mCalculatorErrorID = 0 Then
        txtStatus.ForeColor = vbWindowText
        txtStatus.Text = LookupLanguageCaption(3670, "Ready")
    End If
End Sub

' Purpose: Handle keys pressed in rtfExpression
Private Sub MathTextBoxKeypressHandler(ByRef KeyAscii As Integer)

    Select Case KeyAscii
    Case 40 To 43, 45, 47 To 57, 91, 93, 94, 123, 125
        ' Valid Characters are:
        ' ( and ) are 40 and 41
        ' [ and ] are 91 and 93
        ' { and } are 123 and 125
        ' * is 42
        ' + is 43
        ' - is 45
        ' / is 47
        ' Numbers are 48 to 57
        ' ^ is 94
        boolExpressionChanged = True
    Case 44, 46
        Select Case glbDecimalSeparator
        Case ","
            If KeyAscii = 46 Then
                KeyAscii = 0
                txtStatus.Text = LookupMessage(94)
            End If
        Case Else   ' includes "."
            If KeyAscii = 44 Then
                KeyAscii = 0
                txtStatus.Text = LookupMessage(93)
            End If
        End Select
    Case 8
        ' Backspace; it is valid
        boolExpressionChanged = True
    Case 9
        ' Tab; it is valid
    Case 32
        ' Space
        txtStatus.ForeColor = QBColor(COLOR_ERR)
        txtStatus.Text = LookupMessage(92)
        KeyAscii = 0
    Case vbKeyReturn
        cmdCalculate_Click
        KeyAscii = 0
        LabelStatus
    Case 0
        ' This is set by Form_KeyDown and should just ignore the entry
    Case vbKeyEscape
        ' Ignore the key if it got this far
        KeyAscii = 0
    Case 1
        ' User pressed Ctrl+A (select all)
    Case 3
        ' User pressed CTRL+C (copy)
        CopyRoutine Me, False
    Case 22
        ' User pressed CTRL+V (paste)
        PasteRoutine Me, False
    Case 24
        ' User pressed CTRL+X (cut)
        CutRoutine Me, False
    Case Else
        ' All other ASCII characters are invalid
        txtStatus.ForeColor = QBColor(COLOR_ERR)
        txtStatus.Text = LookupMessage(620) & " " & Chr$(KeyAscii)
        KeyAscii = 0
    End Select

End Sub

Private Function ParseNum(strWork As String, ByRef intNumLength As Integer, Optional blnAllowNegative As Boolean = False) As Double
    ' Looks for a number and returns it if found
    ' If an error is found, it returns a negative number for the error code and sets intNumLength = 0
    '  -1 = No number
    '  -2 =                                             (unused)
    '  -3 = No number at all or (more likely) no number after decimal point
    '  -4 = More than one decimal point
    
    Dim strWorking As String, strFoundNum As String, intIndex As Integer, intDecPtCount As Integer

    If mDecimalSeparator = "" Then
        mDecimalSeparator = DetermineDecimalPoint()
    End If
    
    ' Set intNumLength to -1 for now
    ' If it doesn't get set to 0 (due to an error), it will get set to the
    '   length of the matched number before exiting the sub
    intNumLength = -1
    
    If strWork = "" Then strWork = EMPTY_STRINGCHAR
    If (Asc(Left(strWork, 1)) < 48 Or Asc(Left(strWork, 1)) > 57) And _
       Left(strWork, 1) <> mDecimalSeparator And _
       Not (Left(strWork, 1) = "-" And blnAllowNegative = True) Then
        intNumLength = 0          ' No number found
        ParseNum = -1
    Else
        ' Start of string is a number or a decimal point, or (if allowed) a negative sign
        For intIndex = 1 To Len(strWork)
            strWorking = Mid(strWork, intIndex, 1)
            If IsNumeric(strWorking) Or strWorking = mDecimalSeparator Or _
               (blnAllowNegative = True And strWorking = "-") Then
                strFoundNum = strFoundNum & strWorking
            Else
                Exit For
            End If
        Next intIndex
    
        If Len(strFoundNum) = 0 Or strFoundNum = mDecimalSeparator Then
            ' No number at all or (more likely) no number after decimal point
            strFoundNum = -3
            intNumLength = 0
        Else
            ' Check for more than one decimal point (. or ,)
            intDecPtCount = 0
            For intIndex = 1 To Len(strFoundNum)
                If Mid(strFoundNum, intIndex, 1) = mDecimalSeparator Then intDecPtCount = intDecPtCount + 1
            Next intIndex
            If intDecPtCount > 1 Then
                ' more than one intDecPtCount
                strFoundNum = -4
                intNumLength = 0
            Else
                ' All is fine
            End If
        End If
    
        If intNumLength < 0 Then intNumLength = Len(strFoundNum)
        ParseNum = CDblSafe(strFoundNum)
    End If
    
End Function

' Purpose: Handle parentheses in strExpression; recursive function
Private Function ParseParentheses(strExpression As String, strExpressionChars() As String, intCharIndex As Integer, intStartingCharIndex As Integer, intNumSizing As Integer) As Double
    Dim intExpressionLen As Integer
    Dim intParenthCount As Integer
    Dim intSearchIndex As Integer, boolMatchFound As Boolean
    Dim dblWorkNum As Double
    
    ' Find matching closing parethesis, then recursively call this sub,
    '  sending the numbers and operators between the parentheses as the text string
    ' Will return a numeric result, and can then proceed just like this is a number
    '  except that we must infer what the operator before the parentheses
    '  should be if a number precedes the parentheses
    ' Similary, if a number follows the parentheses, must infer that the operator is a *
    
    intExpressionLen = Len(strExpression)
    
    intParenthCount = 1
    For intSearchIndex = intCharIndex + 1 To intExpressionLen
        Select Case strExpressionChars(intSearchIndex)
        Case "("
            intParenthCount = intParenthCount + 1
        Case ")"
            intParenthCount = intParenthCount - 1
            If intParenthCount = 0 Then
                ' Found matching closing parenthesis
                boolMatchFound = True
                Exit For
            End If
        End Select
    Next intSearchIndex
    
    If Not boolMatchFound Then
        ' Closing parenthesis not found
        mCalculatorErrorID = 2: mCalculatorErrorPosition = intCharIndex + intStartingCharIndex
    Else
        If intSearchIndex = intCharIndex + 1 Then
            ' Nothing in between parentheses; assume 0
            intNumSizing = 0
            dblWorkNum = 0
        Else
            intNumSizing = intSearchIndex - intCharIndex - 1
            dblWorkNum = PerformMath(Mid(strExpression, intCharIndex + 1, intNumSizing), intCharIndex + 1)
        End If
        
        ' Numsizing holds the entire length of the expression, including the parentheses
        intNumSizing = intNumSizing + 2
    End If
    
    ParseParentheses = dblWorkNum
End Function

' Purpose: Compute the result for strExpression
Private Function PerformMath(ByVal strExpression As String, ByVal intStartingCharIndex As Integer) As Double
    ' ( and ) are 40 and 41
    ' + is 43
    ' - is 45
    ' * is 42
    ' / is 47
    ' Numbers are 48 to 57
    ' . is 46
    ' ^ is 94
    
    Dim strOperator(50) As String, bin(50) As Double, dblWorkNum As Double
    Dim intExpressionLen As Integer             ' Expression Length
    Dim intTrack As Integer, intTrackIndex As Integer, intCharIndex As Integer
    Dim intNumSizing As Integer
    Dim boolParenthParsed As Boolean, boolInsertMult As Boolean
    Dim strWork As String, strWork2 As String, strWork3 As String, strWork4 As String
    Dim strExpressionChars() As String, strReplaceChar As String
    
On Error GoTo MathErrorHandler
    
    If mCalculatorErrorID <> 0 Then
        PerformMath = 0
        Exit Function
    End If
    
    intTrack = 1
    bin(1) = 0#
    
    intExpressionLen = Len(strExpression)

    ' Replace all brackets (straight and curly) with parentheses
    For intCharIndex = 1 To intExpressionLen
        Select Case strExpression
        Case "[", "{": strReplaceChar = "("
        Case "]", "}": strReplaceChar = ")"
        Case Else: strReplaceChar = ""
        End Select
        
        If strReplaceChar <> "" Then
            strExpression = Left(strExpression, intCharIndex - 1) & strReplaceChar & Mid(strExpression, intCharIndex + 1)
        End If
    Next intCharIndex
    
    ' Replace all instances of a number followed by () followed by a number,
    '  or )( together with a * for implicit multiplication
    intCharIndex = 1
    Do While intCharIndex < Len(strExpression)
        strWork = Mid(strExpression, intCharIndex, 1)
        strWork2 = Mid(strExpression, intCharIndex + 1, 1)
       
        boolInsertMult = False
        If (IsNumeric(strWork) Or strWork = ".") And strWork2 = "(" Then
            boolInsertMult = True
        ElseIf strWork = ")" Then
            If IsNumeric(strWork2) Or strWork2 = "." Then
                boolInsertMult = True
            ElseIf strWork2 = "(" Then
                boolInsertMult = True
            End If
        End If
        If boolInsertMult Then
            strExpression = Left(strExpression, intCharIndex) & "*" & Mid(strExpression, intCharIndex + 1)
        End If
        intCharIndex = intCharIndex + 1
    Loop
    
    ' Store contents of strExpression in an array
    intExpressionLen = Len(strExpression)
    ReDim strExpressionChars(intExpressionLen + 3)
    For intCharIndex = 1 To intExpressionLen
        strExpressionChars(intCharIndex) = Mid(strExpression, intCharIndex, 1)
    Next intCharIndex
    
    For intCharIndex = 1 To intExpressionLen
        strWork = strExpressionChars(intCharIndex)
        strWork2 = strExpressionChars(intCharIndex + 1)
        strWork3 = strExpressionChars(intCharIndex + 2)
        strWork4 = strExpressionChars(intCharIndex + 3)
        
        If strWork = "" Then strWork = EMPTY_STRINGCHAR
        If strWork2 = "" Then strWork2 = EMPTY_STRINGCHAR
        If strWork3 = "" Then strWork3 = EMPTY_STRINGCHAR
        If strWork4 = "" Then strWork4 = EMPTY_STRINGCHAR
        Select Case Asc(strWork)
            Case 41        ' ), should not be encountered
                ' Unmatched closing parenthesis
                mCalculatorErrorID = 3: mCalculatorErrorPosition = intCharIndex + intStartingCharIndex - 1
                intCharIndex = intExpressionLen
            Case 43, 45                 ' + -
                If intCharIndex <> 1 Then
                    ' Pretend close parentheses
                    If intTrack > 1 Then
                        Select Case strOperator(intTrack)
                        Case "+": bin(intTrack - 1) = bin(intTrack - 1) + bin(intTrack)
                        Case "-": bin(intTrack - 1) = bin(intTrack - 1) - bin(intTrack)
                        Case "*": bin(intTrack - 1) = bin(intTrack - 1) * bin(intTrack)
                        Case "/": bin(intTrack - 1) = bin(intTrack - 1) / bin(intTrack)
                        Case Else
                            ' Missing operator error
                            mCalculatorErrorID = 8: mCalculatorErrorPosition = intCharIndex + intStartingCharIndex - 1
                            intCharIndex = intExpressionLen
                        End Select
                        bin(intTrack) = 0#
                        strOperator(intTrack) = ""
                        intTrack = intTrack - 1
                    Else
                        ' intTrack error
                        mCalculatorErrorID = 7: mCalculatorErrorPosition = intCharIndex + intStartingCharIndex - 1
                        intCharIndex = intExpressionLen
                    End If
                End If

                ' Pretend open parentheses
                intTrack = intTrack + 1
                strOperator(intTrack) = strWork

                boolParenthParsed = False
                If strWork2 = "(" Then
                    dblWorkNum = ParseParentheses(strExpression, strExpressionChars, intCharIndex + 1, intStartingCharIndex, intNumSizing)
                    boolParenthParsed = True
                Else
                    dblWorkNum = ParseNum(Mid(strExpression, intCharIndex + 1), intNumSizing)
                    CatchParsenumErrorInCalculator dblWorkNum
                End If
                
                If mCalculatorErrorID = 0 And strExpressionChars(intCharIndex + 1 + intNumSizing) = "^" Then
                    dblWorkNum = DoPower(dblWorkNum, strExpression, intCharIndex, 2, intNumSizing)
                End If
                
                If mCalculatorErrorID = 0 Then
                    If dblWorkNum < 0 And Not boolParenthParsed Then
                        ' Misplaced operator
                        mCalculatorErrorID = 6: mCalculatorErrorPosition = intCharIndex + intStartingCharIndex - 1
                        intCharIndex = intExpressionLen
                    Else
                        bin(intTrack) = bin(intTrack) + dblWorkNum
                        intCharIndex = intCharIndex + intNumSizing
                    End If
                End If
            Case 42, 47             ' * /
                boolParenthParsed = False
                If strWork2 = "(" Then
                    dblWorkNum = ParseParentheses(strExpression, strExpressionChars, intCharIndex + 1, intStartingCharIndex, intNumSizing)
                    boolParenthParsed = True
                Else
                    dblWorkNum = ParseNum(Mid(strExpression, intCharIndex + 1), intNumSizing)
                    CatchParsenumErrorInCalculator dblWorkNum
                End If
                
                If mCalculatorErrorID = 0 And strExpressionChars(intCharIndex + 1 + intNumSizing) = "^" Then
                    ' Take number to power before multiplying
                    dblWorkNum = DoPower(dblWorkNum, strExpression, intCharIndex, 2, intNumSizing)
                End If
                
                If mCalculatorErrorID = 0 Then
                    If dblWorkNum < 0 And Not boolParenthParsed Then
                        ' Misplaced operator
                        mCalculatorErrorID = 6: mCalculatorErrorPosition = intCharIndex + intStartingCharIndex - 1
                        intCharIndex = intExpressionLen
                    Else
                        If strExpressionChars(intCharIndex - 1) = "" Or intCharIndex = 1 Then
                            ' Misplaced operator
                            mCalculatorErrorID = 6: mCalculatorErrorPosition = intCharIndex + intStartingCharIndex - 1
                            intCharIndex = intExpressionLen
                        Else
                            Select Case strWork
                            Case "*": bin(intTrack) = bin(intTrack) * dblWorkNum
                            Case "/": bin(intTrack) = bin(intTrack) / dblWorkNum
                            Case Else
                            End Select
                            intCharIndex = intCharIndex + intNumSizing
                        End If
                    End If
                End If
            Case 40, 44, 46, 48 To 57      ' (, . or , and Numbers 0 to 9
                boolParenthParsed = False
                If strWork = "(" Then
                    dblWorkNum = ParseParentheses(strExpression, strExpressionChars, intCharIndex, intStartingCharIndex, intNumSizing)
                    boolParenthParsed = True
                Else
                    dblWorkNum = ParseNum(Mid(strExpression, intCharIndex), intNumSizing)
                    CatchParsenumErrorInCalculator dblWorkNum
                End If
                
                If mCalculatorErrorID = 0 And intCharIndex = 1 Then
                    If strExpressionChars(intCharIndex + intNumSizing) = "^" Then
                        dblWorkNum = DoPower(dblWorkNum, strExpression, intCharIndex, 1, intNumSizing)
                    End If
                    If boolParenthParsed Or (mCalculatorErrorID = 0 And dblWorkNum >= 0) Then
                        intTrack = intTrack + 1
                        strOperator(intTrack) = "+"
                        bin(intTrack) = bin(intTrack) + dblWorkNum
                        intCharIndex = intCharIndex + intNumSizing - 1
                    Else
                        ' Misplaced Number
                        If mCalculatorErrorID = 0 Then
                            mCalculatorErrorID = 4: mCalculatorErrorPosition = intCharIndex + intStartingCharIndex - 1
                            intCharIndex = intExpressionLen
                        End If
                    End If
                Else
                    ' ToDo
                    ' Misplaced number ?!?
                End If
            Case 65 To 90, 97 To 122       ' Uppercase A to Z and lowercase a to z
                ' Should not be present
                mCalculatorErrorID = 1: mCalculatorErrorPosition = intCharIndex + intStartingCharIndex - 1
                intCharIndex = intExpressionLen
            Case 94
                ' Caret
                ' Should have been encountered and skipped
                ' Misplaced operator
                mCalculatorErrorID = 6: mCalculatorErrorPosition = intCharIndex + intStartingCharIndex - 1
                intCharIndex = intExpressionLen
            Case Else
        End Select
        If mCalculatorErrorID <> 0 Then Exit For
    Next intCharIndex

    If intTrack > 1 And mCalculatorErrorID = 0 Then
        ' Pretend close parentheses
        For intTrackIndex = intTrack To 2 Step -1
            Select Case strOperator(intTrackIndex)
            Case "+": bin(intTrackIndex - 1) = bin(intTrackIndex - 1) + bin(intTrackIndex)
            Case "-": bin(intTrackIndex - 1) = bin(intTrackIndex - 1) - bin(intTrackIndex)
            Case "*": bin(intTrackIndex - 1) = bin(intTrackIndex - 1) * bin(intTrackIndex)
            Case "/": bin(intTrackIndex - 1) = bin(intTrackIndex - 1) / bin(intTrackIndex)
            Case Else
                ' Missing operator error
                mCalculatorErrorID = 8: mCalculatorErrorPosition = intCharIndex + intStartingCharIndex - 1
                intCharIndex = intExpressionLen
            End Select
            bin(intTrackIndex) = 0#
            strOperator(intTrackIndex) = ""
        Next intTrackIndex
    End If

    PerformMath = bin(1)
    
MathStart:
    Exit Function

MathErrorHandler:
    If Err = 11 Then
        MsgBox LookupMessage(91), vbOKOnly + vbExclamation, LookupMessage(350)
    Else
        GeneralErrorHandler "frmCalculator|PerformMath", Err.Number, Err.Description
    End If
    Resume MathStart

End Function

' Purpose: Position controls on form
Private Sub PositionFormControls()

    With txtStatus
        .Top = 720
        .Left = 120
        .Width = 4300
    End With
    
    With rtfExpression
        .Font.Name = objMwtWin.RtfFontName
        .Font.Size = objMwtWin.RtfFontSize
        .Top = 120
        .Left = 120
        .Width = 2500
    End With
    
    cmdCalculate.Top = 120
    cmdCalculate.Left = 3900
    cmdOK.Top = 600
    cmdOK.Left = 3000

End Sub

' Purpose: Resize form
Private Sub ResizeForm()
    Dim MinFormWidth As Long
    Dim boolSkipWidthAdjust As Boolean
    
    If Me.WindowState = vbNormal Then
        MinFormWidth = TextWidth(txtStatus.Text) + 2100
        If Me.Width < MinFormWidth Then boolSkipWidthAdjust = True
        If Me.Height > 1600 Then Me.Height = 1600
    End If
    
    If Me.WindowState <> vbMinimized Then
        ' Position Objects
        If Not boolSkipWidthAdjust Then
            rtfExpression.Width = Me.Width - 1900     ' FormulaSingle text box
            txtStatus.Width = Me.Width - 1900         ' Status Bar
            cmdCalculate.Left = Me.Width - cmdCalculate.Width - 175     ' Calculate Button
            cmdOK.Left = Me.Width - cmdCalculate.Width - 50  ' Close
        End If
    End If

End Sub

' Purpose: Format rtfExpression when user changes it
Private Sub UpdateRTFExpression()
    Dim intSaveLoc As Integer
    
    boolExpressionChanged = True
    
    intSaveLoc = rtfExpression.SelStart
    rtfExpression.TextRTF = objMwtWin.TextToRTF(rtfExpression.Text, True)
                
    rtfExpression.SelStart = intSaveLoc

End Sub

Private Sub cmdCalculate_Click()
    InitiateMathCalculate
    SetMostRecentTextBoxValue rtfExpression.Text
End Sub

Private Sub cmdOK_Click()
    HideFormShowMain Me
End Sub

Private Sub Form_Activate()
    ' Put window in center of screen
    SizeAndCenterWindow Me, cWindowLowerThird, 4500, 1600
    ResizeForm
    InitiateMathCalculate
End Sub

Private Sub Form_Load()
    mnuRightClick.Visible = False
    PositionFormControls
End Sub

Private Sub Form_QueryUnload(Cancel As Integer, UnloadMode As Integer)
    QueryUnloadFormHandler Me, Cancel, UnloadMode
End Sub

Private Sub Form_Resize()
    ResizeForm
End Sub

Private Sub mnuRightClickCopy_Click()
    CopyRoutinePrivate
End Sub

Private Sub mnuRightClickCut_Click()
    CopyRoutinePrivate
    
    ' Manually need to clear the selected text
    rtfExpression.SelText = ""
End Sub

Private Sub mnuRightClickDelete_Click()
    rtfExpression.SelText = ""
End Sub

Private Sub mnuRightClickPaste_Click()
    Dim strPasteText As String

On Error GoTo RightClickPasteErrorHandler

    ' Place text from Clipboard into active control.
    If Clipboard.GetFormat(vbCFRTF) Then
        ' rtf on clipboard
        strPasteText = GetClipboardTextSmart(vbCFRTF)
        rtfExpression.SelRTF = strPasteText
    Else
        strPasteText = GetClipboardTextSmart()
        rtfExpression.SelText = strPasteText
    End If

RightClickPasteErrorHandler:
    GeneralErrorHandler "frmCalculator|mnuRightClickPaste_Click", Err.Number, Err.Description

End Sub

Private Sub mnuRightClickSelectAll_Click()
    rtfExpression.SelStart = 0
    rtfExpression.SelLength = Len(rtfExpression.Text)
End Sub

Private Sub mnuRightClickUndo_Click()
    rtfExpression.Text = GetMostRecentTextBoxValue()
End Sub

Private Sub rtfExpression_Change()
    UpdateRTFExpression
End Sub

Private Sub rtfExpression_GotFocus()
    SetMostRecentTextBoxValue rtfExpression.Text
End Sub

Private Sub rtfExpression_KeyDown(KeyCode As Integer, Shift As Integer)
    
    If mCalculatorErrorID <> 0 Then
        ' Reset error flags, then update status line
        mCalculatorErrorID = 0:
        LabelStatus
    End If

End Sub

Private Sub rtfExpression_KeyPress(KeyAscii As Integer)
    MathTextBoxKeypressHandler KeyAscii
End Sub

Private Sub rtfExpression_MouseUp(Button As Integer, Shift As Integer, x As Single, y As Single)
    If Button = vbRightButton Then
        ShowPopupRightClickMenu Me, rtfExpression, True
    End If
End Sub
